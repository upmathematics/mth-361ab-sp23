---
title: "Data Basics & Sampling Principles <br><br> MTH 361 A/B <br> Applied Statistics I <br> Spring 2023"
author: University of Portland
date: "2022-01-23"
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# R Packages {.bigger}

```{r message=FALSE, warning=FALSE, paged.print=FALSE, echo=TRUE}
library(tidyverse)
library(openintro)
```

R packages are groups of R functions, compiled code, and example data. In the R environment, they are saved in the `library` directory. R installs a set of packages by default after installation. More packages will be added later if they are required for a specific purpose. When we launch the R console, just the default packages are available. Other packages that are already installed must be explicitly loaded before they may be utilized by the R application.

# Loading Datasets {.bigger}

```{r loading-data-from-package, message=FALSE, echo=TRUE}
county %>%
  slice(1:3) # selecting only 3 rows to display
```

The syntax `%>%` is a method to pipe results to another function. The `county` dataset is built in R dataset.

# Accessing Rows and Columns {.bigger}

  * Using brackets to access **specific indices** of the data frame with the first 3 rows.
```{r rows-and-columns-1, message=FALSE, echo=TRUE}
county[1:3,1:5]
```

  * Using brackets to access **specific column labels** of the data frame with the first 3 rows.
```{r rows-and-columns-2, message=FALSE, echo=TRUE}
county[1:3,c("name","state","pop2000","pop2010")]
```

# Accessing Entire Columns {.bigger}

  * Using the `$` command to access a **specific column label** of the data.
```{r rows-and-columns-3, message=FALSE, echo=TRUE}
glimpse(county$pop2000)
```

  * Using brackets to access **entire columns** using **specific column labels**.
```{r rows-and-columns-4, message=FALSE, echo=TRUE}
glimpse(county[,c("pop2000","pop2010","pop2017")])
```

# Basic Descriptive Statistics {.bigger}

  * Using `$` command to **summarize one column**.
```{r summarize-data-1, message=FALSE, echo=TRUE}
summary(county$pop2000)
```

  * Using brackets to **summarize multiple columns**.
```{r summarize-data-2, message=FALSE, echo=TRUE}
summary(county[,c("pop2000","pop2010","pop2017")])
```

  * Computing **Mean and Standard Deviation of one column**.
```{r means-and-standard-deviations-1, message=FALSE, echo=TRUE}
mean(county$pop2010)
sd(county$pop2010)
```

# Histograms {.bigger}

```{r basic-data-visualization-1, message=FALSE, echo=TRUE}
ggplot(data = county, aes(x = pop2000)) + geom_histogram(bins=60)
```

# Scatterplots {.bigger}

```{r basic-data-visualization-2, message=FALSE, echo=TRUE}
ggplot(data = county, aes(x = unemployment_rate, y = poverty)) + geom_point()
```

# **Randomization and Sampling**

<br>

Throughout this section, we are using the [`county`](https://www.openintro.org/data/index.php?data=county){target="_blank"} dataset. Note that this data set is already part of the base R installation.

```{r echo=TRUE}
county <- county %>% na.omit()
glimpse(county)
```

# Simple Random Sampling

*Example:* Suppose we want to randomly sample 100 observations (rows) from the data frame.

```{r echo=TRUE}
n <- 100 # number of samples
rand_index <- sample.int(dim(county)[1],n, replace = FALSE) # pick random row indices from the data frame
# the replace=FALSE means that we sampling without replacement
simple_random_sample <- county %>% slice(rand_index) # select rows using the random indices
glimpse(simple_random_sample)
```

# Stratified Random Sampling

*Example 1:* Suppose we want to sample 50\% of observations of each state in the data frame.

```{r echo=TRUE}
strat_sample_frac <- county %>%
                     group_by(state) %>%# group by state (states as strata)
                     mutate(num_rows=n()) %>% # create new column that counts the number of observations in each strata
                     sample_frac(0.50, weight=num_rows) %>% # randomly sample 50% of observations in each strata
                     ungroup()
```

Now, let's check if the code did it right.

```{r echo=TRUE}
nto <- dim(county %>% filter(state == "California"))[1] # number of total observations
nso <- dim(strat_sample_frac %>% filter(state == "California"))[1] # number of sample observations

# this value should be close to 0.50
nso/nto
```

*Example 2:* Suppose we want to sample exactly 100 observations in each level of the `metro` variable.

```{r echo=TRUE}
stratified_sample <- county %>% 
                     group_by(metro) %>%# group by metro (metro - yes or no - as strata)
                     sample_n(100) %>% # randomly sample 100 observations in each strata
                     ungroup

stratified_sample
```

# Clustered Random Sampling

*Example:* Suppose we consider each state as a cluster, and we randomly sample 10 clusters.

```{r echo=TRUE}
n_clusters <- 10 # number of clusters to randomly sample
states <- levels(county$state) # get list of states
states_sample <- sample(states,n_clusters) # sample the states

county %>% filter(state==states_sample) # get the rows with corresponding states that are sampled.
```
